import ast
import re
import traceback
import pandas as pd


class DataAnalysisAgent:

    def __init__(self, llm, dfs, return_type=None, retry=3):
        self.llm = llm
        self.dfs = dfs
        self.question = ''
        self.last_code_executed = ''
        self.code_exception = ''
        self.max_retry = retry
        self.return_type = return_type
        self.dfs_prompt = self.generate_dfs_prompt(dfs)

    def _polish_code(self, code: str) -> str:
        """
        Polish the code by removing the leading "python" or "py",  \
        removing the imports and removing trailing spaces and new lines.
        Args:
            code (str): A string of Python code.
        Returns:
            str: Polished code.
        """
        if re.match(r"^(python|py)", code):
            code = re.sub(r"^(python|py)", "", code)
        if re.match(r"^`.*`$", code):
            code = re.sub(r"^`(.*)`$", r"\1", code)
        code = code.strip()
        return code

    def _is_python_code(self, string):
        """
        Return True if it is valid python code.
        Args:
            string (str):
        Returns (bool): True if Python Code otherwise False
        """
        try:
            ast.parse(string)
            return True
        except SyntaxError:
            return False

    def _extract_code(self, response: str, separator: str = "```") -> str:
        """
        Extract the code from the response.
        Args:
            response (str): Response
            separator (str, optional): Separator. Defaults to "```".
        Raises:
            NoCodeFoundError: No code found in the response
        Returns:
            str: Extracted code from the response
        """
        code = response

        if separator not in response:
            raise ValueError("No code found in the response")

        if len(code.split(separator)) > 1:
            code = code.split(separator)[1]
        code = self._polish_code(code)
        return code

    def convert_df_to_csv(self, df: pd.DataFrame, index) -> str:
        """
        Convert df to csv like format where csv is wrapped inside <dataframe></dataframe>
        Args:
            df (pd.DataFrame): PandasAI dataframe or dataframe
            extras (dict, optional): expect index to exists

        Returns:
            str: dataframe stringify
        """
        dataframe_info = "<dataframe>"
        # Add dataframe details
        dataframe_info += f"\ndfs[{index}]:{df.shape[0]}x{df.shape[1]}\n{df.head(3).to_csv()}"
        # Close the dataframe tag
        dataframe_info += "</dataframe>\n"
        return dataframe_info

    def generate_dfs_prompt(self, dfs):
        '''
        生成dfs描述prompt
        :return:
        '''
        dfs_prompt = '\n'.join([self.convert_df_to_csv(dfs[i], i) for i in range(len(dfs))])
        dfs_prompt = f"""现有一个变量 dfs: list[pd.DataFrame]，每个dataframe示例数据如下：\n{dfs_prompt}"""
        return dfs_prompt

    def generate_code(self, prompt):
        result_example_prompt = '{ "type": "string", "value": "100" } or { "type": "dataframe", "value": pd.DataFrame({...}) } or { "type": "html", "value": line.render_embed() }'
        prompt = f"""
{self.dfs_prompt}
Update this initial code:
```python
# TODO: import the required dependencies

# Write code here

# Declare result var: 
type (possible values "string", "dataframe", "html"). Example: {result_example_prompt}

```

### QUERY

{prompt}

Variable `dfs: list[pd.DataFrame]` is already declared.

At the end, declare "result" variable as a dictionary of type and value.

If you are asked to plot a chart, use "pyecharts" for charts, use the render_embed() function to return the corresponding html type and the html content value.

Generate python code and return full updated code:
"""
        print(prompt)
        self.llm_result = self.llm(prompt)
        code = self._extract_code(self.llm_result)
        return code

    def fix_code(self):
        '''
        使用llm修正错误代码
        :return:
        '''
        fix_code_prompt = f"""
{self.dfs_prompt}
The user asked the following question:
{self.question}

You generated this python code:
{self.last_code_executed}

the code running throws an exception:
{self.code_exception}

Fix the python code above and return the new python code
        """
        self.llm_result = self.llm(fix_code_prompt)
        new_code = self._extract_code(self.llm_result)
        return new_code

    def execute_code(self, code: str):
        """
        Execute the python code generated by LLMs to answer the question
        about the input dataframe. Run the code in the current context and return the
        result.
        Args:
            code (str): Python code to execute.
            context (CodeExecutionContext): Code Execution Context
                    with prompt id and skills.
        Returns:
            Any: The result of the code execution. The type of the result depends
                on the generated code.
        """
        try:
            environment = {'dfs': self.dfs}
            exec(code, environment)
            self.last_code_executed = code
            if "result" not in environment:
                raise ValueError("No result returned")
            else:
                result = environment['result']
                # if self.return_type and not isinstance(result['type'], self.return_type):
                #     raise ValueError(f'Value type {type(result["value"])} must match with type {result["type"]}')
                return result
        except Exception as e:
            self.last_code_executed = code
            raise e

    def run(self, prompt):
        self.question = prompt
        code = agent.generate_code(prompt)
        retry_count = 0
        result = None
        while retry_count <= self.max_retry:
            try:
                print(code)
                result = self.execute_code(code)
                break
            except Exception as e:
                traceback_errors = traceback.format_exc()
                self.code_exception = traceback_errors
                retry_count += 1
                code = self.fix_code()
        return result


if __name__ == '__main__':
    from web_apps.llm.utils import get_llm
    llm = get_llm()
    df = pd.read_excel('demo.xlsx')
    dfs = [df]
    prompt = f"""
    数据有几行，几列？
    """
    agent = DataAnalysisAgent(llm, dfs)
    res = agent.run(prompt)
    print(res)
    # value = res['value']
    # f = open('1.html', 'w')
    # f.write(value)